<!DOCTYPE html>
<html>
<head>
	<title>RollBall</title>
	<script type="text/javascript" src="libs/glMatrix-0.9.5.min.js"></script>
	<script type="text/javascript" src="libs/webgl-utils.js"></script>

	<script id="shader-fs" type="x-shader/x-fragment">
		precision mediump float;

		varying vec2 vTextureCoord;
		varying vec3 vLighWeighting;

		uniform sampler2D uSampler;

		void main(){
			vec4 textureColor = texture2D(uSampler, vTextureCoord);
			gl_FragColor = vec4(textureColor.rgb * vLighWeighting, textureColor.a);
		}
	</script>

	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;
		attribute vec2 aTextureCoord;
		attribute vec3 aVertexNormal;

		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

		uniform vec3 uAmbientColor;
		uniform vec3 uLightingDirection;
		uniform vec3 uDirectionalColor;

		varying vec2 vTextureCoord;
		varying vec3 vLighWeighting;

		void main(){
			gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
			vTextureCoord = aTextureCoord;

			vec3 transformedNormal = uNMatrix * aVertexNormal;
			float directionLighWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
			vLighWeighting = uAmbientColor + uDirectionalColor * directionLighWeighting;
		}
	</script>

	<script type="text/javascript">
		var gl; 
		function initWebgl(canvas) {
			canvas = document.getElementById("mycanvas");
			try{
				gl = canvas.getContext("experimental-webgl");
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
			} catch (e) {}
			canvas = document.getElementById("scoreboard");
  			scoreBoard = canvas.getContext("2d");
			if (!gl) {
			        alert("Could not initialise Scoreboard, sorry :-(");
			}
		}

		function getShader(id){
			var shaderScript = document.getElementById(id);
			if (!shaderScript) return null;
			var myString = "";
			var key = shaderScript.firstChild;
			while (key){
				if (key.nodeType == 3)
					myString += key.textContent;
				key = key.nextSibling;
			}
			var shader;
			if (shaderScript.type == "x-shader/x-fragment")
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			else if (shaderScript.type == "x-shader/x-vertex")
				shader = gl.createShader(gl.VERTEX_SHADER);
			else return null;
			gl.shaderSource(shader, myString);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
				return null;
			return shader;
		}

		var shaderProgram;
		function initShader() {
			var fragmentShader = getShader("shader-fs");
			var vertexShader = getShader("shader-vs");
			shaderProgram = gl.createProgram();
			gl.attachShader(shaderProgram, vertexShader);
			gl.attachShader(shaderProgram, fragmentShader);
			gl.linkProgram(shaderProgram);
			gl.useProgram(shaderProgram);
			shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
			gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
			shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
			gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
			shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
			gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
			shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
			shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
			shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
			shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
			shaderProgram.uambientColor = gl.getUniformLocation(shaderProgram, "uAmbientColor");
			shaderProgram.ulightingDirection = gl.getUniformLocation(shaderProgram, "uLightingDirection");
			shaderProgram.udirectionalColor = gl.getUniformLocation(shaderProgram, "uDirectionalColor");
		}

		function loadedTexture(texture) {
		    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		    gl.bindTexture(gl.TEXTURE_2D, texture);
		    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
		    gl.generateMipmap(gl.TEXTURE_2D);
		    gl.bindTexture(gl.TEXTURE_2D, null);
		}

		var textureBall;
		var textureObstacle;
		var textureGround;
		function initTexture() {
			textureBall = gl.createTexture();
			textureBall.image = new Image();	
			textureBall.image.onload = function() {
				loadedTexture(textureBall);
			}
			textureBall.image.src = "libs/Ball.png";

			textureObstacle = gl.createTexture();
			textureObstacle.image = new Image();
			textureObstacle.image.onload = function(){
				loadedTexture(textureObstacle);
			}
			textureObstacle.image.src = "libs/Cube.jpg";

			textureGround = gl.createTexture();
			textureGround.image = new Image();
			textureGround.image.onload = function(){
				loadedTexture(textureGround);
			}
			textureGround.image.src = "libs/Ground.jpg";
		}

		var mvMatrix = mat4.create();
		var pMatrix = mat4.create();
		var mvMatrixStack = [];

		function mvPushMatrix() {
		        var copy = mat4.create();
		        mat4.set(mvMatrix, copy);
		        mvMatrixStack.push(copy);
		}

		function mvPopMatrix() 
		{
	        if (mvMatrixStack.length == 0) {
	            throw "Invalid popMatrix!";
			}		
			mvMatrix = mvMatrixStack.pop();
		}
		function setMatrixUniforms() 
		{
			gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
	        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
	        var normalMatrix = mat3.create();
	        mat4.toInverseMat3(mvMatrix, normalMatrix);
	        mat3.transpose(normalMatrix);
	        gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
		}

		function degToRad(degrees) 
		{
			return degrees * Math.PI / 180;
		}

		var GroundNormalBuffer;
		var GroundVertexBuffer;
		var GroundTextureBuffer;
		function initBackground()
		{
			var vertices = new Float32Array([
	            // Front face
			    -1.0, 1.0, 0.0,
			    1.0, 1.0, 0.0,
			    1.0, -1.0, 0.0,
			    -1.0, -1.0, 0.0,
			    
	        ]);
			GroundVertexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, GroundVertexBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
	        GroundVertexBuffer.itemSize = 3;
	        GroundVertexBuffer.numItems = 4;

			var vertexNormal = new Float32Array([
				// Front face
	             0.0,  0.0,  1.0,
	             0.0,  0.0,  1.0,
	             0.0,  0.0,  1.0,
	             0.0,  0.0,  1.0
			]);
	        GroundNormalBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, GroundNormalBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, vertexNormal, gl.STATIC_DRAW);
			GroundNormalBuffer.itemSize = 3;
			GroundNormalBuffer.numItems = 4;

	        var textureCoods = new Float32Array([
      			0.0, 0.0,
          		1.0, 0.0,
          		1.0, 1.0,
          		0.0, 1.0
	        ]);
	        GroundTextureBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, GroundTextureBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, textureCoods, gl.STATIC_DRAW);
	        GroundTextureBuffer.itemSize = 2;
	        GroundTextureBuffer.numItems = 4;
		}

		var CubeIndexBuffer;
		var CubeNormalBuffer;
		var CubeVertexBuffer;
		var CubeTextureBuffer;
		function initCube()
		{

			var vertices = new Float32Array([
	            // Front face
	            -1.0, -1.0,  1.0,
	             1.0, -1.0,  1.0,
	             1.0,  1.0,  1.0,
	            -1.0,  1.0,  1.0,

	            // Back face
	            -1.0, -1.0, -1.0,
	            -1.0,  1.0, -1.0,
	             1.0,  1.0, -1.0,
	             1.0, -1.0, -1.0,

	            // Top face
	            -1.0,  1.0, -1.0,
	            -1.0,  1.0,  1.0,
	             1.0,  1.0,  1.0,
	             1.0,  1.0, -1.0,

	            // Bottom face
	            -1.0, -1.0, -1.0,
	             1.0, -1.0, -1.0,
	             1.0, -1.0,  1.0,
	            -1.0, -1.0,  1.0,

	            // Right face
	             1.0, -1.0, -1.0,
	             1.0,  1.0, -1.0,
	             1.0,  1.0,  1.0,
	             1.0, -1.0,  1.0,

	            // Left face
	            -1.0, -1.0, -1.0,
	            -1.0, -1.0,  1.0,
	            -1.0,  1.0,  1.0,
	            -1.0,  1.0, -1.0
	        ]);
			CubeVertexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, CubeVertexBuffer);	        
	        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
	        CubeVertexBuffer.itemSize = 3;
	        CubeVertexBuffer.numItems = 24;

			var vertexNormal = new Float32Array([
				// Front face
	             0.0,  0.0,  1.0,
	             0.0,  0.0,  1.0,
	             0.0,  0.0,  1.0,
	             0.0,  0.0,  1.0,

	            // Back face
	             0.0,  0.0, -1.0,
	             0.0,  0.0, -1.0,
	             0.0,  0.0, -1.0,
	             0.0,  0.0, -1.0,

	            // Top face
	             0.0,  1.0,  0.0,
	             0.0,  1.0,  0.0,
	             0.0,  1.0,  0.0,
	             0.0,  1.0,  0.0,

	            // Bottom face
	             0.0, -1.0,  0.0,
	             0.0, -1.0,  0.0,
	             0.0, -1.0,  0.0,
	             0.0, -1.0,  0.0,

	            // Right face
	             1.0,  0.0,  0.0,
	             1.0,  0.0,  0.0,
	             1.0,  0.0,  0.0,
	             1.0,  0.0,  0.0,

	            // Left face
	            -1.0,  0.0,  0.0,
	            -1.0,  0.0,  0.0,
	            -1.0,  0.0,  0.0,
	            -1.0,  0.0,  0.0
			]);
	        CubeNormalBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, CubeNormalBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, vertexNormal, gl.STATIC_DRAW);
			CubeNormalBuffer.itemSize = 3;
			CubeNormalBuffer.numItems = 24;

	        var textureCoods = new Float32Array([
		    	// Front face
		          0.0, 0.0,
		          1.0, 0.0,
		          1.0, 1.0,
		          0.0, 1.0,

		          // Back face
		          1.0, 0.0,
		          1.0, 1.0,
		          0.0, 1.0,
		          0.0, 0.0,

		          // Top face
		          0.0, 1.0,
		          0.0, 0.0,
		          1.0, 0.0,
		          1.0, 1.0,

		          // Bottom face
		          1.0, 1.0,
		          0.0, 1.0,
		          0.0, 0.0,
		          1.0, 0.0,

		          // Right face
		          1.0, 0.0,
		          1.0, 1.0,
		          0.0, 1.0,
		          0.0, 0.0,

		          // Left face
		          0.0, 0.0,
		          1.0, 0.0,
		          1.0, 1.0,
		          0.0, 1.0
	        ]);
	        CubeTextureBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, CubeTextureBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, textureCoods, gl.STATIC_DRAW);
	        CubeTextureBuffer.itemSize = 2;
	        CubeTextureBuffer.numItems = 24;

			var cubeVertexIndices = new Uint16Array([
			       0,  1,  2,    0,  2,  3,    
			       4,  5,  6,    4,  6,  7,    
			       8,  9, 10,    8, 10, 11,  
			      12, 13, 14,   12, 14, 15, 
			      16, 17, 18,   16, 18, 19, 
			      20, 21, 22,   20, 22, 23 
    		]);
			CubeIndexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, CubeIndexBuffer);
    		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndices, gl.STATIC_DRAW);
    		CubeIndexBuffer.itemSize = 1;
    		CubeIndexBuffer.numItems = 36;
		}

		var BallVertexBuffer;
	    var BallNormalBuffer;
	    var BallTextureBuffer;
	    var BallIndexBuffer;
		function initSphere() {
			var latitudeBands = 30;
	        var longitudeBands = 30;
	        var radius = 1;
	        var vertexPositionData = [];
	        var normalData = [];
	        var textureCoordData = [];
	        for (var i=0; i <= latitudeBands; i++) {
	            var theta = i * Math.PI / latitudeBands;
	            var sinTheta = Math.sin(theta);
	            var cosTheta = Math.cos(theta);
	            for (var j=0; j <= longitudeBands; j++) {
	                var phi = j * 2 * Math.PI / longitudeBands;
	                var sinPhi = Math.sin(phi);
	                var cosPhi = Math.cos(phi);
	                var x = cosPhi * sinTheta;
	                var y = cosTheta;
	                var z = sinPhi * sinTheta;
	                var u = 1 - (j / longitudeBands);
	                var v = 1 - (i / latitudeBands);
	                normalData.push(x);
	                normalData.push(y);
	                normalData.push(z);
	                textureCoordData.push(u);
	                textureCoordData.push(v);
	                vertexPositionData.push(radius * x);
	                vertexPositionData.push(radius * y);
	                vertexPositionData.push(radius * z);
	            }
        	}

	        BallNormalBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, BallNormalBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
	        BallNormalBuffer.itemSize = 3;
	        BallNormalBuffer.numItems = normalData.length / 3;

	        BallTextureBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, BallTextureBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
	        BallTextureBuffer.itemSize = 2;
	        BallTextureBuffer.numItems = textureCoordData.length / 2;

	        BallVertexBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, BallVertexBuffer);
	        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
	        BallVertexBuffer.itemSize = 3;
	        BallVertexBuffer.numItems = vertexPositionData.length / 3;

	        var indexData = [];
	        for (var i=0; i < latitudeBands; i++) {
	            for (var j=0; j < longitudeBands; j++) {
	                var first = (i * (longitudeBands + 1)) + j;
	                var second = first + longitudeBands + 1;
	                indexData.push(first);
	                indexData.push(second);
	                indexData.push(first + 1);

	                indexData.push(second);
	                indexData.push(second + 1);
	                indexData.push(first + 1);
	            }
	        }
	        BallIndexBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, BallIndexBuffer);
	        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
	        BallIndexBuffer.itemSize = 1;
	        BallIndexBuffer.numItems = indexData.length;
		}

		function lighting(){
	        var lightingDirection = [1,-0.75,0];
	        var adjustedLD = vec3.create();
	        vec3.normalize(lightingDirection, adjustedLD);
	        vec3.scale(adjustedLD, -1);
	        gl.uniform3fv(shaderProgram.ulightingDirection, adjustedLD);
			gl.uniform3f(shaderProgram.uambientColor, 0.5, 0.5, 0.5);
	        gl.uniform3f(shaderProgram.udirectionalColor, 0.15,0.15,0.15);
		}

		var eyeX = 0, eyeY = -3., eyeZ = 2;
		var atX = 0, atY = 0, atZ = 0.05;
		function drawGround(){
			mvPushMatrix();
	        gl.bindBuffer(gl.ARRAY_BUFFER, GroundVertexBuffer);
	        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, GroundVertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
	        gl.bindBuffer(gl.ARRAY_BUFFER, GroundNormalBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, GroundNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	        gl.bindBuffer(gl.ARRAY_BUFFER, GroundTextureBuffer);
	        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, GroundTextureBuffer.itemSize, gl.FLOAT, false, 0, 0);
	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, textureGround);
	        gl.uniform1i(shaderProgram.samplerUniform, 0);
	        setMatrixUniforms();
	        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
	        mvPopMatrix();
		}

		var Rx = 0, Ry = 0, Rz = 0;
		var angBall = 0;
		function ball(x, y)
		{
			this.x = x;
			this.y = y;
		}

		ball.prototype.draw = function()
		{
			mvPushMatrix()
			mat4.translate(mvMatrix, [this.x, this.y, 0.05]);
			mat4.scale(mvMatrix, [0.05, 0.05, 0.05]);
			mat4.rotate(mvMatrix, degToRad(angBall), [Rx, Ry, Rz]);		
			mat4.rotate(mvMatrix, degToRad(angBall), [Rx, Ry, Rz]);		
			gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, textureBall);
	        gl.uniform1i(shaderProgram.samplerUniform, 0);
	        gl.bindBuffer(gl.ARRAY_BUFFER, BallVertexBuffer);
	        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, BallVertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
	        gl.bindBuffer(gl.ARRAY_BUFFER, BallTextureBuffer);
        	gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, BallTextureBuffer.itemSize, gl.FLOAT, false, 0, 0);
	        gl.bindBuffer(gl.ARRAY_BUFFER, BallNormalBuffer);
	        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, BallNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, BallIndexBuffer);
	        setMatrixUniforms();
	        gl.drawElements(gl.TRIANGLES, BallIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	        mvPopMatrix();
		}

		function cube(x, y)
		{
			this.x = x;
			this.y = y;
			this.z = 1.5*0.05;
			this.isAlive = false;
			this.score = 1;
		}
		var Score = 0;
		var currentAngle = 0;
		cube.prototype.draw = function()
		{
			mvPushMatrix();
			mat4.translate(mvMatrix, [this.x, this.y, this.z]);
			mat4.scale(mvMatrix, [0.05, 0.05, 0.05]);
	       	mat4.rotate(mvMatrix, degToRad(currentAngle), [0, 0, 1]);
	        mat4.rotate(mvMatrix, degToRad(currentAngle), [0, 1, 0]);
	        mat4.rotate(mvMatrix, degToRad(currentAngle), [1, 0, 0]);
	        setMatrixUniforms();
	        gl.drawElements(gl.TRIANGLES, CubeIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
	        mvPopMatrix();
		}

		var Obstacle = [];
		var Ball = new ball(0, 0);
		function initArrayCube(R, angle)
		{
	      	var x, y;
		    Obstacle.push(new cube(0.8, 0));
		    Obstacle.push(new cube(-0.8, 0));
		    Obstacle.push(new cube(0, -0.8));
		    Obstacle.push(new cube(0, 0.8));
			for (var i = 30; i < 90; i+= angle)
			{
			    x = Math.cos(degToRad(i))*R;
			    y = Math.sin(degToRad(i))*R;
			    Obstacle.push(new cube(x, y));
			    Obstacle.push(new cube(-x, y));
			    Obstacle.push(new cube(-x, -y));
			    Obstacle.push(new cube(x, -y));
			    
			}
			return;
		}
		
		function drawObstacles() 
		{
	        gl.bindBuffer(gl.ARRAY_BUFFER, CubeVertexBuffer);
	        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, CubeVertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
	        gl.bindBuffer(gl.ARRAY_BUFFER, CubeNormalBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, CubeNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	        gl.bindBuffer(gl.ARRAY_BUFFER, CubeTextureBuffer);
	        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, CubeTextureBuffer.itemSize, gl.FLOAT, false, 0, 0);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, CubeIndexBuffer);
	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, textureObstacle);
	        gl.uniform1i(shaderProgram.samplerUniform, 0);
			for (var i in Obstacle) {
				if (Obstacle[i].isAlive != -1) {
					Obstacle[i].draw();
				}
				else if (Obstacle[i].score == 1 ) {
					var crash = document.getElementById("ting");	
					crash.load();
					crash.play();
					Score += 100;
					Obstacle[i].score = -1;
				}
			}
		}

		function initBuffer()
		{
			initSphere();
			initCube();
			initBackground();
			initArrayCube(0.8, 30);
		}

		var currentlyPressedKeys = [];
		var distCamtoBall = 2;
		var distCamtoGround = 1.5;
		function handleKeyDown(event)
		{
			currentlyPressedKeys[event.keyCode] = true;
		}

		function handleKeyUp(event)
		{
			currentlyPressedKeys[event.keyCode] = false;
		} 

		function isObstacle(x, y)
		{
			for (var i in Obstacle) {
			    if ((Math.abs(Obstacle[i].x - x) <= 0.1) && (Math.abs(Obstacle[i].y - y) <= 0.1)) {
			      Obstacle[i].isAlive = -1;
			      return true;
			    }
			}
			return false;
		}

		function isB(x)
		{
	  		if (x >= 1 || x <= -1)
	  			return false;
	  		return true;
		}
			
		function drawScene()
		{
			gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			gl.enable(gl.DEPTH_TEST);
			mat4.identity(pMatrix);
  			mat4.perspective(30, gl.viewportWidth/gl.viewportHeight, 1, 100, pMatrix);
			mat4.identity(mvMatrix);
			mat4.lookAt([eyeX, eyeY, eyeZ], [atX, atY, atZ], [0, 0, 1], mvMatrix);
			lighting();
			drawGround();
			Ball.draw();
			drawObstacles();
			drawScoreBoard();
		}

		function handleKeys() //Move
		{
		//Right and Up
			if (currentlyPressedKeys[39] && currentlyPressedKeys[38]) {
				if (isB(Ball.x + 0.02)) {
					Ball.x += 0.02; 
					isObstacle(Ball.x, Ball.y);
				}
				if (isB(Ball.y + 0.02)) {
					Ball.y += 0.02; 
					isObstacle(Ball.x, Ball.y);
				}
				angBall += 5; 
				Rx = -1; 
				Ry = 1;
				atX = Ball.x;
				atY = Ball.y;
				eyeY = atY - distCamtoBall;
				eyeX = atX; 
				eyeZ = atZ + distCamtoGround;
			} else
		//Right and Down
			if (currentlyPressedKeys[39] && currentlyPressedKeys[40]) {
				if (isB(Ball.x + 0.02)) {
					Ball.x += 0.02; 
					isObstacle(Ball.x, Ball.y);
				}
				if (isB(Ball.y - 0.02)) {
					Ball.y -= 0.02; 
					isObstacle(Ball.x, Ball.y);
				}
				angBall -= 5; 
				Rx = -1; 
				Ry = -1;
				atX = Ball.x;
				atY = Ball.y;
				eyeY = atY - distCamtoBall;
				eyeX = atX; 
				eyeZ = atZ + distCamtoGround;
			} else
		//Left and Up
			if (currentlyPressedKeys[37] && currentlyPressedKeys[38]) {
				if (isB(Ball.x - 0.02)) {
					Ball.x -= 0.02; 
					isObstacle(Ball.x, Ball.y);
				}

				if (isB(Ball.y + 0.02)) {
					Ball.y += 0.02; 
					isObstacle(Ball.x, Ball.y);
				}
				angBall += 5; 
				Rx = -1; 
				Ry = -1;
				atX = Ball.x;
				atY = Ball.y;
				eyeY = atY - distCamtoBall;
				eyeX = atX; 
				eyeZ = atZ + distCamtoGround;
			} else
		//Left and Down
			if (currentlyPressedKeys[37] && currentlyPressedKeys[40]) {
				if (isB(Ball.x - 0.02)) {
					Ball.x -= 0.02; 
					isObstacle(Ball.x, Ball.y);
				}
				if (isB(Ball.y - 0.02)) {
					Ball.y -= 0.02; 
					isObstacle(Ball.x, Ball.y);
				}
				angBall -= 5; 
				Rx = -1; 
				Ry = 1;
				atX = Ball.x;
				atY = Ball.y;
				eyeY = atY - distCamtoBall;
				eyeX = atX; 
				eyeZ = atZ + distCamtoGround;
			} else
		//Right
		    if(currentlyPressedKeys[39]) {
				if (isB(Ball.x + 0.02)) {
					Ball.x += 0.02; 
					isObstacle(Ball.x, Ball.y);
				}
				angBall += 5; 
				Rx = 0; 
				Ry = 1;
				atX = Ball.x;
				atY = Ball.y;
				eyeY = atY - distCamtoBall;
				eyeX = atX; 
				eyeZ = atZ + distCamtoGround;
		    } else
		//Left
		    if(currentlyPressedKeys[37]) {
				if (isB(Ball.x - 0.02)) {
					Ball.x -= 0.02; 
					isObstacle(Ball.x, Ball.y);
				}
				angBall -= 5; 
				Rx = 0; 
				Ry = 1; 
				atX = Ball.x;
				atY = Ball.y;
				eyeY = atY - distCamtoBall; 
				eyeX = atX; 
				eyeZ = atZ + distCamtoGround;
		    } else
		//Up
		    if(currentlyPressedKeys[38]) {
				if (isB(Ball.y + 0.02)) {
					Ball.y += 0.02; 
					isObstacle(Ball.x, Ball.y);
				}
				angBall -= 5; 
				Ry = 0;
				Rx = 1; 
				atX = Ball.x;
				atY = Ball.y;
				eyeY = atY - distCamtoBall; 
				eyeX = atX; 
				eyeZ = atZ + distCamtoGround;
		    } else
		//Down
		    if(currentlyPressedKeys[40]) {
				if (isB(Ball.y - 0.02)) {
					Ball.y -= 0.02; 
					isObstacle(Ball.x, Ball.y);
				}
				angBall += 5; 
				Ry = 0;
				Rx = 1; 
				atX = Ball.x;
				atY = Ball.y;
				eyeY = atY - distCamtoBall;
				eyeX = atX; 
				eyeZ = atZ + distCamtoGround;
		    } 
		}

		var g_last = Date.now();
		var ANGLE_STEP = 30;
		function animate(angle)
		{
		  var now = Date.now();
		  var elapsed = now - g_last;
		  g_last = now;
		  var newAngle = angle + (ANGLE_STEP*elapsed)/1000.0;
		  return newAngle %= 360;  
		}

		function tick() 
		{
			currentAngle = animate(currentAngle);
			drawScene();
			requestAnimationFrame(tick);
			handleKeys();
		}

		var scoreBoard;
		var canvas;
		function webGLStart() {
			initWebgl(canvas);
			initShader();
			initBuffer();
			initTexture();	
			gl.clearColor(0.5, 0.5, 0.5, 1.0);
			gl.enable(gl.DEPTH_TEST);
			document.onkeydown = handleKeyDown;
			document.onkeyup = handleKeyUp;		
			tick();
		}

		function drawScoreBoard() 
		{
		    scoreBoard.clearRect(0, 0, gl.viewportWidth, gl.viewportHeight);
		    scoreBoard.font = '35px Times New Roman';
		    scoreBoard.fillStyle = 'rgba(0, 245, 255, 1)';
		    scoreBoard.fillText('Your Score: ' + Score, 500, 60);
		    if(WinGame()) 
		    {
		    	var str = document.getElementById("start");
		    	str.pause();
		    	var end = document.getElementById("win");
		    	end.play();
		        scoreBoard.clearRect(0, 0, gl.viewportWidth, gl.viewportHeight);
		        scoreBoard.font = '45px Times New Roman';
		        scoreBoard.fillStyle = 'rgba(0, 255 , 0, 1)';
		        scoreBoard.fillText('Congratulation on you!!!', 400, 250);
		        scoreBoard.fillText('<3 You win <3', 470, 300);
		        scoreBoard.font = '30px Times New Roman';
		        scoreBoard.fillStyle = 'rgba(255, 255, 0, 1)';
		        scoreBoard.fillText('New Highest Score: ' + Score, 460 , 340);
		        setTimeout(function(){location.reload();}, 7500);
		    }
		}

		function WinGame() {
			for (var i in Obstacle)
				if (Obstacle[i].isAlive != -1) 
					return false;
			return true;
		}

	</script>
</head>
<body onload="webGLStart();">
	<br>
	<canvas id="mycanvas" style="border: none;" width="1200px" height="600px"></canvas>
	<canvas id="scoreboard" width="1200" height="600" style="position: absolute;left:0">
	</canvas>
	</br>
	<audio id = "start"  autoplay loop>
       <source src="libs/background.mp3" type="audio/mp3" />
       Your browser does not support the <audio> element.
   </audio>
   <audio id = "ting"> <source src="libs/ting.mp3" type="audio/mp3" /> </audio>
   <audio id = "win"> <source src="libs/win.mp3" type="audio/mp3" /> </audio>
</body>
</html>